"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  assembleHangul: () => assembleHangul,
  canBeChosung: () => canBeChosung,
  canBeJongsung: () => canBeJongsung,
  canBeJungsung: () => canBeJungsung,
  chosungIncludes: () => chosungIncludes,
  combineHangulCharacter: () => combineHangulCharacter,
  combineVowels: () => combineVowels,
  convertQwertyToHangul: () => convertQwertyToHangul,
  convertQwertyToHangulAlphabet: () => convertQwertyToHangulAlphabet,
  curriedCombineHangulCharacter: () => curriedCombineHangulCharacter,
  disassembleCompleteHangulCharacter: () => disassembleCompleteHangulCharacter,
  disassembleHangul: () => disassembleHangul,
  disassembleHangulToGroups: () => disassembleHangulToGroups,
  getChosung: () => getChosung,
  getFirstConsonants: () => getFirstConsonants,
  hangulIncludes: () => hangulIncludes,
  hasBatchim: () => hasBatchim,
  hasProperty: () => hasProperty,
  hasSingleBatchim: () => hasSingleBatchim,
  hasValueInReadOnlyStringList: () => hasValueInReadOnlyStringList,
  josa: () => josa,
  removeLastHangulCharacter: () => removeLastHangulCharacter
});
module.exports = __toCommonJS(src_exports);

// src/constants.ts
var COMPLETE_HANGUL_START_CHARCODE = "\uAC00".charCodeAt(0);
var COMPLETE_HANGUL_END_CHARCODE = "\uD7A3".charCodeAt(0);
var NUMBER_OF_JONGSUNG = 28;
var NUMBER_OF_JUNGSUNG = 21;
var DISASSEMBLED_CONSONANTS_BY_CONSONANT = {
  // 종성이 없는 경우 '빈' 초성으로 관리하는 것이 편리하여, 빈 문자열도 포함한다.
  "": "",
  \u3131: "\u3131",
  \u3132: "\u3132",
  \u3133: "\u3131\u3145",
  \u3134: "\u3134",
  \u3135: "\u3134\u3148",
  \u3136: "\u3134\u314E",
  \u3137: "\u3137",
  \u3138: "\u3138",
  \u3139: "\u3139",
  \u313A: "\u3139\u3131",
  \u313B: "\u3139\u3141",
  \u313C: "\u3139\u3142",
  \u313D: "\u3139\u3145",
  \u313E: "\u3139\u314C",
  \u313F: "\u3139\u314D",
  \u3140: "\u3139\u314E",
  \u3141: "\u3141",
  \u3142: "\u3142",
  \u3143: "\u3143",
  \u3144: "\u3142\u3145",
  \u3145: "\u3145",
  \u3146: "\u3146",
  \u3147: "\u3147",
  \u3148: "\u3148",
  \u3149: "\u3149",
  \u314A: "\u314A",
  \u314B: "\u314B",
  \u314C: "\u314C",
  \u314D: "\u314D",
  \u314E: "\u314E"
};
var DISASSEMBLED_VOWELS_BY_VOWEL = {
  \u314F: "\u314F",
  \u3150: "\u3150",
  \u3151: "\u3151",
  \u3152: "\u3152",
  \u3153: "\u3153",
  \u3154: "\u3154",
  \u3155: "\u3155",
  \u3156: "\u3156",
  \u3157: "\u3157",
  \u3158: "\u3157\u314F",
  \u3159: "\u3157\u3150",
  \u315A: "\u3157\u3163",
  \u315B: "\u315B",
  \u315C: "\u315C",
  \u315D: "\u315C\u3153",
  \u315E: "\u315C\u3154",
  \u315F: "\u315C\u3163",
  \u3160: "\u3160",
  \u3161: "\u3161",
  \u3162: "\u3161\u3163",
  \u3163: "\u3163"
};
var HANGUL_CHARACTERS_BY_FIRST_INDEX = [
  "\u3131",
  "\u3132",
  "\u3134",
  "\u3137",
  "\u3138",
  "\u3139",
  "\u3141",
  "\u3142",
  "\u3143",
  "\u3145",
  "\u3146",
  "\u3147",
  "\u3148",
  "\u3149",
  "\u314A",
  "\u314B",
  "\u314C",
  "\u314D",
  "\u314E"
];
var HANGUL_CHARACTERS_BY_MIDDLE_INDEX = Object.values(DISASSEMBLED_VOWELS_BY_VOWEL);
var HANGUL_CHARACTERS_BY_LAST_INDEX = [
  "",
  "\u3131",
  "\u3132",
  "\u3133",
  "\u3134",
  "\u3135",
  "\u3136",
  "\u3137",
  "\u3139",
  "\u313A",
  "\u313B",
  "\u313C",
  "\u313D",
  "\u313E",
  "\u313F",
  "\u3140",
  "\u3141",
  "\u3142",
  "\u3144",
  "\u3145",
  "\u3146",
  "\u3147",
  "\u3148",
  "\u314A",
  "\u314B",
  "\u314C",
  "\u314D",
  "\u314E"
].map((consonant) => DISASSEMBLED_CONSONANTS_BY_CONSONANT[consonant]);
var QWERTY_KEYBOARD_MAP = {
  q: "\u3142",
  Q: "\u3143",
  w: "\u3148",
  W: "\u3149",
  e: "\u3137",
  E: "\u3138",
  r: "\u3131",
  R: "\u3132",
  t: "\u3145",
  T: "\u3146",
  y: "\u315B",
  Y: "\u315B",
  u: "\u3155",
  U: "\u3155",
  i: "\u3151",
  I: "\u3151",
  o: "\u3150",
  O: "\u3152",
  p: "\u3154",
  P: "\u3156",
  a: "\u3141",
  A: "\u3141",
  s: "\u3134",
  S: "\u3134",
  d: "\u3147",
  D: "\u3147",
  f: "\u3139",
  F: "\u3139",
  g: "\u314E",
  G: "\u314E",
  h: "\u3157",
  H: "\u3157",
  j: "\u3153",
  J: "\u3153",
  k: "\u314F",
  K: "\u314F",
  l: "\u3163",
  L: "\u3163",
  z: "\u314B",
  Z: "\u314B",
  x: "\u314C",
  X: "\u314C",
  c: "\u314A",
  C: "\u314A",
  v: "\u314D",
  V: "\u314D",
  b: "\u3160",
  B: "\u3160",
  n: "\u315C",
  N: "\u315C",
  m: "\u3161",
  M: "\u3161"
};

// src/disassembleCompleteHangulCharacter.ts
function disassembleCompleteHangulCharacter(letter) {
  const charCode = letter.charCodeAt(0);
  const isCompleteHangul = COMPLETE_HANGUL_START_CHARCODE <= charCode && charCode <= COMPLETE_HANGUL_END_CHARCODE;
  if (!isCompleteHangul) {
    return void 0;
  }
  const hangulCode = charCode - COMPLETE_HANGUL_START_CHARCODE;
  const lastIndex = hangulCode % NUMBER_OF_JONGSUNG;
  const middleIndex = (hangulCode - lastIndex) / NUMBER_OF_JONGSUNG % NUMBER_OF_JUNGSUNG;
  const firstIndex = Math.floor((hangulCode - lastIndex) / NUMBER_OF_JONGSUNG / NUMBER_OF_JUNGSUNG);
  return {
    first: HANGUL_CHARACTERS_BY_FIRST_INDEX[firstIndex],
    middle: HANGUL_CHARACTERS_BY_MIDDLE_INDEX[middleIndex],
    last: HANGUL_CHARACTERS_BY_LAST_INDEX[lastIndex]
  };
}

// src/utils.ts
function hasBatchim(str) {
  const lastChar = str[str.length - 1];
  if (lastChar == null) {
    return false;
  }
  const disassembled = disassembleCompleteHangulCharacter(lastChar);
  return disassembled != null && disassembled.last !== "";
}
function hasSingleBatchim(str) {
  const lastChar = str[str.length - 1];
  if (lastChar == null || hasBatchim(lastChar) === false) {
    return false;
  }
  const disassembled = disassembleHangul(lastChar);
  return disassembled.length === 3;
}
function getChosung(word) {
  return disassembleHangulToGroups(word).reduce((chosung, [consonant]) => {
    return `${chosung}${consonant}`;
  }, "");
}
function getFirstConsonants(word) {
  return disassembleHangulToGroups(word).reduce((firstConsonants, [consonant]) => {
    return `${firstConsonants}${consonant}`;
  }, "");
}
function canBeChosung(character) {
  return hasValueInReadOnlyStringList(HANGUL_CHARACTERS_BY_FIRST_INDEX, character);
}
function canBeJungsung(character) {
  return hasValueInReadOnlyStringList(HANGUL_CHARACTERS_BY_MIDDLE_INDEX, character);
}
function canBeJongsung(character) {
  return hasValueInReadOnlyStringList(HANGUL_CHARACTERS_BY_LAST_INDEX, character);
}
function hasValueInReadOnlyStringList(list, value) {
  return list.some((item) => item === value);
}
function hasProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

// src/disassemble.ts
function disassembleHangulToGroups(str) {
  const result = [];
  for (const letter of str) {
    const disassembledComplete = disassembleCompleteHangulCharacter(letter);
    if (disassembledComplete != null) {
      result.push([...disassembledComplete.first, ...disassembledComplete.middle, ...disassembledComplete.last]);
      continue;
    }
    if (hasProperty(DISASSEMBLED_CONSONANTS_BY_CONSONANT, letter)) {
      const disassembledConsonant = DISASSEMBLED_CONSONANTS_BY_CONSONANT[letter];
      result.push([...disassembledConsonant]);
      continue;
    }
    if (hasProperty(DISASSEMBLED_VOWELS_BY_VOWEL, letter)) {
      const disassembledVowel = DISASSEMBLED_VOWELS_BY_VOWEL[letter];
      result.push([...disassembledVowel]);
      continue;
    }
    result.push([letter]);
  }
  return result;
}
function disassembleHangul(str) {
  return disassembleHangulToGroups(str).reduce((hanguls, disassembleds) => `${hanguls}${disassembleds.join("")}`, "");
}

// src/_internal/index.ts
function excludeLastElement(array) {
  const lastElement = array[array.length - 1];
  return [array.slice(0, -1), lastElement != null ? lastElement : ""];
}
function joinString(...args) {
  return args.join("");
}
function isBlank(character) {
  return /^\s$/.test(character);
}
function assert(condition, errorMessage) {
  if (condition === false) {
    throw new Error(errorMessage != null ? errorMessage : "Invalid condition");
  }
}

// src/combineHangulCharacter.ts
function combineHangulCharacter(firstCharacter, middleCharacter, lastCharacter = "") {
  if (canBeChosung(firstCharacter) === false || canBeJungsung(middleCharacter) === false || canBeJongsung(lastCharacter) === false) {
    throw new Error(`Invalid hangul Characters: ${firstCharacter}, ${middleCharacter}, ${lastCharacter}`);
  }
  const numOfMiddleCharacters = HANGUL_CHARACTERS_BY_MIDDLE_INDEX.length;
  const numOfLastCharacters = HANGUL_CHARACTERS_BY_LAST_INDEX.length;
  const firstCharacterIndex = HANGUL_CHARACTERS_BY_FIRST_INDEX.indexOf(firstCharacter);
  const middleCharacterIndex = HANGUL_CHARACTERS_BY_MIDDLE_INDEX.indexOf(middleCharacter);
  const lastCharacterIndex = HANGUL_CHARACTERS_BY_LAST_INDEX.indexOf(lastCharacter);
  const firstIndexOfTargetConsonant = firstCharacterIndex * numOfMiddleCharacters * numOfLastCharacters;
  const firstIndexOfTargetVowel = middleCharacterIndex * numOfLastCharacters;
  const unicode = COMPLETE_HANGUL_START_CHARCODE + firstIndexOfTargetConsonant + firstIndexOfTargetVowel + lastCharacterIndex;
  return String.fromCharCode(unicode);
}
var curriedCombineHangulCharacter = (firstCharacter) => (middleCharacter) => (lastCharacter = "") => combineHangulCharacter(firstCharacter, middleCharacter, lastCharacter);
var combineVowels = (vowel1, vowel2) => {
  var _a, _b;
  return (_b = (_a = Object.entries(DISASSEMBLED_VOWELS_BY_VOWEL).find(([, value]) => value === `${vowel1}${vowel2}`)) == null ? void 0 : _a[0]) != null ? _b : `${vowel1}${vowel2}`;
};

// src/removeLastHangulCharacter.ts
function removeLastHangulCharacter(words) {
  const disassembledGroups = disassembleHangulToGroups(words);
  const lastCharacter = disassembledGroups.at(-1);
  if (lastCharacter == null) {
    return "";
  }
  const withoutLastCharacter = disassembledGroups.filter((v) => v !== lastCharacter).map(([first2, middle2, last2]) => {
    if (middle2 != null) {
      return combineHangulCharacter(first2, middle2, last2);
    }
    return first2;
  });
  const [[first, middle, last]] = excludeLastElement(lastCharacter);
  const result = middle != null ? combineHangulCharacter(first, middle, last) : first;
  return [...withoutLastCharacter, result].join("");
}

// src/_internal/hangul.ts
function isHangulCharacter(character) {
  return /^[가-힣]$/.test(character);
}
function isHangulAlphabet(character) {
  return /^[ㄱ-ㅣ]$/.test(character);
}
function binaryAssembleHangulAlphabets(source, nextCharacter) {
  if (canBeJungsung(`${source}${nextCharacter}`)) {
    return combineVowels(source, nextCharacter);
  }
  const isConsonantSource = canBeJungsung(source) === false;
  if (isConsonantSource && canBeJungsung(nextCharacter)) {
    return combineHangulCharacter(source, nextCharacter);
  }
  return joinString(source, nextCharacter);
}
function linkHangulCharacters(source, nextCharacter) {
  const sourceJamo = disassembleHangulToGroups(source)[0];
  const [, lastJamo] = excludeLastElement(sourceJamo);
  return joinString(removeLastHangulCharacter(source), combineHangulCharacter(lastJamo, nextCharacter));
}
function binaryAssembleHangulCharacters(source, nextCharacter) {
  assert(
    isHangulCharacter(source) || isHangulAlphabet(source),
    `Invalid source character: ${source}. Source must be one character.`
  );
  assert(
    isHangulAlphabet(nextCharacter),
    `Invalid next character: ${nextCharacter}. Next character must be one of the chosung, jungsung, or jongsung.`
  );
  const sourceJamos = disassembleHangulToGroups(source)[0];
  const isSingleCharacter = sourceJamos.length === 1;
  if (isSingleCharacter) {
    const sourceCharacter = sourceJamos[0];
    return binaryAssembleHangulAlphabets(sourceCharacter, nextCharacter);
  }
  const [restJamos, lastJamo] = excludeLastElement(sourceJamos);
  const needLinking = canBeChosung(lastJamo) && canBeJungsung(nextCharacter);
  if (needLinking) {
    return linkHangulCharacters(source, nextCharacter);
  }
  const fixConsonant = curriedCombineHangulCharacter;
  const combineJungsung = fixConsonant(restJamos[0]);
  if (canBeJungsung(`${lastJamo}${nextCharacter}`)) {
    return combineJungsung(`${lastJamo}${nextCharacter}`)();
  }
  if (canBeJungsung(lastJamo) && canBeJongsung(nextCharacter)) {
    return combineJungsung(lastJamo)(nextCharacter);
  }
  const fixVowel = combineJungsung;
  const combineJongsung = fixVowel(restJamos[1]);
  const lastConsonant = lastJamo;
  if (hasSingleBatchim(source) && canBeJongsung(`${lastConsonant}${nextCharacter}`)) {
    return combineJongsung(`${lastConsonant}${nextCharacter}`);
  }
  return joinString(source, nextCharacter);
}
function binaryAssembleHangul(source, nextCharacter) {
  const [rest, lastCharacter] = excludeLastElement(source.split(""));
  const needJoinString = isBlank(lastCharacter) || isBlank(nextCharacter);
  return joinString(
    ...rest,
    needJoinString ? joinString(lastCharacter, nextCharacter) : binaryAssembleHangulCharacters(lastCharacter, nextCharacter)
  );
}

// src/assemble.ts
function assembleHangul(words) {
  const disassembled = disassembleHangul(words.join("")).split("");
  return disassembled.reduce(binaryAssembleHangul);
}

// src/chosungIncludes.ts
function chosungIncludes(x, y) {
  const trimmedY = y.replace(/\s/g, "");
  if (!isOnlyChosung(trimmedY)) {
    return false;
  }
  const chosungX = getChosung(x).replace(/\s/g, "");
  const chosungY = trimmedY;
  return chosungX.includes(chosungY);
}
function isOnlyChosung(str) {
  const groups = disassembleHangulToGroups(str);
  if (groups.length === 0) {
    return false;
  }
  return groups.every((disassembled) => {
    return disassembled.length === 1 && canBeChosung(disassembled[0]);
  });
}

// src/convertQwertyToHangulAlphabet.ts
function convertQwertyToHangulAlphabet(word) {
  return word.split("").map((inputText) => hasProperty(QWERTY_KEYBOARD_MAP, inputText) ? QWERTY_KEYBOARD_MAP[inputText] : inputText).join("");
}
function convertQwertyToHangul(word) {
  if (!word) {
    return "";
  }
  return assembleHangul([...convertQwertyToHangulAlphabet(word)]);
}

// src/hangulIncludes.ts
function hangulIncludes(x, y) {
  const disassembledX = disassembleHangul(x);
  const disassembledY = disassembleHangul(y);
  return disassembledX.includes(disassembledY);
}

// src/josa.ts
var \uB85C_\uC870\uC0AC = ["\uC73C\uB85C/\uB85C", "\uC73C\uB85C\uC11C/\uB85C\uC11C", "\uC73C\uB85C\uC368/\uB85C\uC368", "\uC73C\uB85C\uBD80\uD130/\uB85C\uBD80\uD130"];
function josa(word, josa2) {
  if (word.length === 0) {
    return word;
  }
  return word + josaPicker(word, josa2);
}
josa.pick = josaPicker;
function josaPicker(word, josa2) {
  var _a;
  if (word.length === 0) {
    return josa2.split("/")[0];
  }
  const has\uBC1B\uCE68 = hasBatchim(word);
  let index = has\uBC1B\uCE68 ? 0 : 1;
  const is\uC885\uC131\u3139 = ((_a = disassembleCompleteHangulCharacter(word[word.length - 1])) == null ? void 0 : _a.last) === "\u3139";
  const isCaseOf\uB85C = has\uBC1B\uCE68 && is\uC885\uC131\u3139 && \uB85C_\uC870\uC0AC.includes(josa2);
  if (josa2 === "\uC640/\uACFC" || isCaseOf\uB85C) {
    index = index === 0 ? 1 : 0;
  }
  const isEndsWith\uC774 = word[word.length - 1] === "\uC774";
  if (josa2 === "\uC774\uC5D0\uC694/\uC608\uC694" && isEndsWith\uC774) {
    index = 1;
  }
  return josa2.split("/")[index];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assembleHangul,
  canBeChosung,
  canBeJongsung,
  canBeJungsung,
  chosungIncludes,
  combineHangulCharacter,
  combineVowels,
  convertQwertyToHangul,
  convertQwertyToHangulAlphabet,
  curriedCombineHangulCharacter,
  disassembleCompleteHangulCharacter,
  disassembleHangul,
  disassembleHangulToGroups,
  getChosung,
  getFirstConsonants,
  hangulIncludes,
  hasBatchim,
  hasProperty,
  hasSingleBatchim,
  hasValueInReadOnlyStringList,
  josa,
  removeLastHangulCharacter
});
